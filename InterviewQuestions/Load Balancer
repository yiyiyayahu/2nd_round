第四轮：一个白人小年轻，也是一脸笑嘻嘻的，但仍然掩饰不住问题的刁钻。让我设计 load balancer
这题比较开放，我讲了几种大概的思路，但他刁钻的提出让我从多线程的角度去分析，
如果一下来了太多的 load request 怎么办，如果你与 server 之间的沟通有延迟怎么办，怎么设置安全锁来保证你得到的当前各个 server 的状态是实时的。
我去，我记得当时我也就看了关于 load balancer 的几种处理思路，没有考虑这么多的细节，答得不是很好。
从来刷题也没刷到过考多线程这么深的问题，不知多线程问题在Google是不是很多被问到，还是我太背啊。

这个要好好准备一下啊。。。看来真正面试还真不是单纯的刷题那么简单。。。哭了


load balancer一个简单的算法就是round robin，但是有很多drawback，就是load分配不均，很可能有的server就overload，有的server没事儿干
然后呢，可以通过和server通信看这个server有多么busy来决定分配给谁

关于thread都有点忘差不多了，赶紧复习一下
https://www.javacodegeeks.com/2014/11/multithreading-concurrency-interview-questions-answers.html


For what purposes is the keyword synchronized used?
When you have to implement exclusive access to a resource, like some static value or some file reference, 
the code that works with the exclusive resource can be embraced with a synchronized block:

synchronized (SynchronizedCounter.class) {
    counter++;
}

37. What do we understand by a deadlock?
A deadlock is a situation in which two (or more) threads are each waiting on the other thread to free a resource that it has locked, 
while the thread itself has locked a resource the other thread is waiting on:
Thread 1: locks resource A, waits for resource B
Thread 2: locks resource B, waits for resource A

38. What are the requirements for a deadlock situation?
In general the following requirements for a deadlock can be identified:
Mutual exclusion: There is a resource which can be accessed only by one thread at any point in time.
Resource holding: While having locked one resource, the thread tries to acquire another lock on some other exclusive resource.
No preemption: There is no mechanism, which frees the resource if one thread holds the lock for a specific period of time.
Circular wait: During runtime a constellation occurs in which two (or more) threads are each waiting on the other thread to free a resource 
that it has locked.

39. Is it possible to prevent deadlocks at all?
In order to prevent deadlocks one (or more) of the requirements for a deadlock has to be eliminated:
Mutual exclusion: In some situation it is possible to prevent mutual exclusion by using optimistic locking.
Resource holding: A thread may release all its exclusive locks, when it does not succeed in obtaining all exclusive locks.
No preemption: Using a timeout for an exclusive lock frees the lock after a given amount of time.
Circular wait: When all exclusive locks are obtained by all threads in the same sequence, no circular wait occurs.

40. Is it possible to implement a deadlock detection?
When all exclusive locks are monitored and modelled as a directed graph, a deadlock detection system can search for 
two threads that are each waiting on the other thread to free a resource that it has locked. 
The waiting threads can then be forced by some kind of exception to release the lock the other thread is waiting on.

