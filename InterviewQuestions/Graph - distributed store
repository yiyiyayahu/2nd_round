白人大叔一进来就看了看面试记录，说我先看看别人都问了什么问题，我别问重了。如何找圣诞歌曲，有意思。
然后说他的问题是开放性的。有一个图，图中每一个节点的label是一个整数，找到最长的连续整数序列的长度。
例如
1
\
2- 3
\ /
4
|
5-8
|/
7

最长连续数列是 2-3-4-5，就返回4(结点个数)或者3(边的个数)都行。

我就说先取出结点列表，然后对结点列表进行排序， 从最小的结点开始做 DFS 找到最长路径。他说好，开始 coding.
我就写了一个 recursive DFS。
问：如果图特别大这段代码会有什么问题么？
答：recursive 函数的调用次数有限制，如果路径的长度大于次数限制就会失败。我说也可以用 iterative DFS 来解决问题。

问：如果图特别大，超出了一台电脑的内存限制怎么办？
答：把图分成多个小图，分别计算再合并，例如上图中的 4-5 节点切断就可以将图分开。

问：如果3-8之间有 edge， 如果找到最合适的分割点？
答：先将图中无效的边都去掉，例如 1-3， 2-4， 3-8， 5-7， 5-8。将图简化后就容易找到分割点了。

问：如果这些子图在不同的服务器上分布，如果解决
答：每一台服务器分别计算自己图中所有的连续区间。另外一台电脑逐个询问这些服务器，对可以合并的区间进行合并，找到最长的区间。

问：如果有 n 台服务器，这个合并的时间复杂度是多少
答：O(n)

问：能不能优化？
答：可以每两个服务器先合并自己的区间，这样做的时间复杂度是 O(logn)

问：如何配对两台将要合并区间的服务器？
答：按每台服务器上的最大区间的起始数字对服务器进行排序，选择相邻的区间进行合并。

问：为什么这么做？
答：凭直觉，每台服务器上的最大的区间更有可能是总区间的一份子。
