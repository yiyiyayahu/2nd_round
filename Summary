把常见的错误或者注意写在这里

对于string的操作：
比如像wordladder那里，可以把s.toCharArray，String.valueOf(arr)就好了，因为是对string的每一位操作

char to int:
==============
Character.getNumericValue() returns the character's value as a digit.
It returns -1 if the character is not a digit.
额，其实直接c-'0'就可以了

If you want to get the numeric Unicode code:
int value = (int) c;
==============

==============
int[] to ArrayList<Integer> 
没有什么好办法。。。Arrays.toList(arr)是不行的，因为arr一定要是Integer[]，也不能直接初始化new ArrayList<Integer>(arr)
==============

Heap
==============
最大堆：根结点的键值是所有堆结点键值中最大者的堆。
最小堆：根结点的键值是所有堆结点键值中最小者的堆。
kth largest - min heap
PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k);
java自带的PriorityQueue - min heap
max heap:
PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
    	return o2-o1;
    }
});
==============
word break I,II可以再做一下，题还挺好的
number of islands写的很乱啊，可以再练一下
spiral matrix虽然不难，但是很难写对，再练一下
Substring with Concatenation of All Words这道题实在是。。又难想又难写，我发现two pointer的string题好难处理啊，苦

我应该学一下greedy algorithm，不然我遇到这种题基本就是没思路。。。


==================
有一些array的题可以利用index这个信息，比如first missing positive, remove element ...
一些string，用到hashmap这个思想来查找的时候，可以转换成int[256]的array，然后char可以直接作为index这样 char c= 'a'; int[c]=1;

其实常见的无非就是那么几类题型，可以试着套一套
有时候可以先根据时间复杂度套，一般naive的解法很可能是O(n^2)
那么这个题有没有可能O(n)? two pointer?
如果一定要有一个n的循环的话，循环里面有没有可能是O(1)，如果不行，那最好就是O(logn)，这时候想想binary search啊啥的。。。我觉得我需要突击练一下binary search！

对于dp的题，一定就直接想递推式，要么就是从前往后推，要么就是从后往前推，我容易犯的一个毛病是，从前往后推 推着推着就想recursive了，就乱了，现在这点有改进
dfs呢，一般就是要把所有情况都考虑到，难一点的题要加上剪枝，这个要注意看一下


==================
很多考到int的题都要考虑下溢出！
Integer.MIN_VALUE是"-2147483648"，要比Integer.MAX_VALUE大
比如Fraction to Recurring Decimal这道题，没办法把这个直接转换成正数。这样就溢出了！！！太变态了，所以要用long
那如果long/long结果还是long，这点也要注意！！！

==================
ArrayList functions
list.set(index, element)
list.insert(index, element)
