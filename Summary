把常见的错误或者注意写在这里

对于string的操作：
比如像wordladder那里，可以把s.toCharArray，String.valueOf(arr)就好了，因为是对string的每一位操作

char to int:
==============
Character.getNumericValue() returns the character's value as a digit.
It returns -1 if the character is not a digit.
额，其实直接c-'0'就可以了

If you want to get the numeric Unicode code:
int value = (int) c;
==============

==============
int[] to ArrayList<Integer> 
没有什么好办法。。。Arrays.toList(arr)是不行的，因为arr一定要是Integer[]，也不能直接初始化new ArrayList<Integer>(arr)
==============

Heap
==============
最大堆：根结点的键值是所有堆结点键值中最大者的堆。
最小堆：根结点的键值是所有堆结点键值中最小者的堆。
kth largest - min heap
PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k);
java自带的PriorityQueue - min heap
max heap:
PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
    	return o2-o1;
    }
});
==================
有一些array的题可以利用index这个信息，比如first missing positive, remove element ...
一些string，用到hashmap这个思想来查找的时候，可以转换成int[256]的array，然后char可以直接作为index这样 char c= 'a'; int[c]=1;

其实常见的无非就是那么几类题型，可以试着套一套
有时候可以先根据时间复杂度套，一般naive的解法很可能是O(n^2)
那么这个题有没有可能O(n)? two pointer?
如果一定要有一个n的循环的话，循环里面有没有可能是O(1)，如果不行，那最好就是O(logn)，这时候想想binary search啊啥的。。。我觉得我需要突击练一下binary search！

对于dp的题，一定就直接想递推式，要么就是从前往后推，要么就是从后往前推，我容易犯的一个毛病是，从前往后推 推着推着就想recursive了，就乱了，现在这点有改进
dfs呢，一般就是要把所有情况都考虑到，难一点的题要加上剪枝，这个要注意看一下


==================
很多考到int的题都要考虑下溢出！
Integer.MIN_VALUE是"-2147483648"，要比Integer.MAX_VALUE大
比如Fraction to Recurring Decimal这道题，没办法把这个直接转换成正数。这样就溢出了！！！太变态了，所以要用long
那如果long/long结果还是long，这点也要注意！！！

==================
ArrayList functions
list.set(index, element)
list.insert(index, element)

String s = s.toLowerCase();
Character.isDigit(char c)
Character.isLetter(char c)

===================
面试的时候先不要急不要慌
1. 搞清楚题意
2. 说思路的时候慢一点整理一下再慢慢说，不要着急
3. design high level一点的东西，就别想实现的detail，先想想自己要干什么，练练如何说思路
大概我的一些variable是怎么define的
比如recursive的function的话我的function主要是用来干什么的？



===================
算法
看算法视频啊书啊的一些看法：
1. 为什么很多时候O(n^2)的时间复杂度不太acceptable呢
诚然，现在的计算机比以前处理的快了，但是同时存储的信息也多了
比如现在memory可以存10^18的东西，但是再平方的话就很恐怖不是么。。。。
（memory就是计算机处理时候的RAM，不是disk space也不是cpu。。。）
所以算法向来是，在小数据上面体现并不一定明显
但是算法解决的问题是，如果时间不够fast，或者space不够，我要如何做
以前一直觉得算法没什么大用，可是实际上，是人类多少年的思想的结晶啊。。。。

==============
没什么思路的话就举例子想想怎么得出的结果

==============
再做一下的题：
wildcard matching！虽然和regular expression matching类似，但是我发现code不是那么好写

word break I,II可以再做一下，题还挺好的
number of islands写的很乱啊，可以再练一下
spiral matrix虽然不难，但是很难写对，再练一下
Substring with Concatenation of All Words这道题实在是。。又难想又难写，我发现two pointer的string题好难处理啊，苦

我应该学一下greedy algorithm，不然我遇到这种题基本就是没思路。。。
